<!DOCTYPE html>
<html>
  <head>
    <title>Introduction to Digital Design</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { 
        font-family: 'Droid Serif'; 
        line-height: 1.6;
        }

      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: bold;
        color: #00467F;
      }

      h1{
        margin-top: 30px !important;
        margin-bottom: 30px !important;
      }

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .TitleAuthor {
        color:white; 
        font-weight: normal;
      }

      .title-slide .remark-slide-number {
        display: none;
      }
      .title-slide h1, h2, h3, h4 {
        text-align: left;
        color:white;
        line-height: 0.7;
        font-weight: bold;
      }

      .title-slide {
        vertical-align: middle;
        background-color: #00467F;
      }

      .logo-title {
        content: "";
        position: absolute;
        top: 15px;
        right:   15px;
        height: 88px;
        width: 267px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url(https://cdn.auckland.ac.nz/assets/central/central-services/mediaandmarketing/uoa-logos-2015/uoa-logo-2015-reverse.png);
      }
      .logo-slide {
        content: "";
        position: absolute;
        top: 35px;
        right:   15px;
        height: 96px;
        width: 100px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url(https://cpb-ap-se2.wpmucdn.com/blogs.auckland.ac.nz/dist/d/79/files/2015/10/uoa-v-colour2.png);
      }

      .left-column {
        width: 65%;
        float: left;
        word-wrap: break-word;
      }
     
      .right-column {
        width: 30%;
        float: right;
        word-wrap: break-word;
      }

      .left-column-s {
        width: 75%;
        float: left;
        word-wrap: break-word;
      }
     
      .right-column-s {
        width: 20%;
        float: right;
        word-wrap: break-word;
      }

      .footer {
        content: "";
        position: absolute;
        bottom: 17px;
        color:gray;
        font-size: 10pt;
      }
      
      @page {
        size: 1210px 681px;
        margin: 0;
      }

      @media print {
        .remark-slide-scaler {
          width: 100% !important;
          height: 100% !important;
          transform: scale(1) !important;
          top: 0 !important;
          left: 0 !important;
        }
      }
      
      .credits {
        font-size: 12px;
        line-height: 10px !important;
        font-family: 'Droid Serif'; 
      }

      .codes {
        
        line-height: 20px !important;
      }

      .zoom175 {
        transition: transform .2s; /* Animation */
      }

      .zoom175:hover {
        transform: scale(1.75) translateY(-20%) translateX(-20%); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */
      }

    </style>

    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
    <style>
    .smaller-font { font-size:14px } 
    </style>

    <!-- KaTeX and Mathjax support refer to below for syntax -->
    <!-- https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    
    <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <style>
      /* Table Style */
      .tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;}
      .tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
        font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:2px 10px;word-break:normal;}
      .tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
        font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:2px 10px;word-break:normal;}
      .tg .tg-dzaw{background-color:#4F81BD;color:#FFF;font-weight:bold;text-align:left;vertical-align:top}
      .tg .tg-sabo{background-color:#ebf5ff;color:#000000;text-align:left;vertical-align:top}
      .tg .tg-096r{color:#000000;text-align:left;vertical-align:top}
      .tg .tg-jayl{background-color:#d2e4fc;color:#000000;text-align:left;vertical-align:top}
      .tg .tg-ig71{background-color:#D2E4FC;color:#000000;text-align:left;vertical-align:top}
    </style>

  </head>
  <body>
    <textarea id="source">

class: title-slide
count: false
.logo-title[]

## ELECTENG 209
# Embedded Software Design 
### An Introduction

.TitleAuthor[Duleepa J Thrimawithana]

---

layout: true
name: template_slide

.logo-slide[]
.footer[[Duleepa J Thrimawithana](https://www.linkedin.com/in/duleepajt), Department of Electrical, Computer and Software Engineering (2020)]

---

name: S1

# Learning Objectives

- Why do we use a digital processor in your design?
- What should be the functionality of your digital design?
- What are the differences between microcontrollers and reconfigurable integrated circuits?
- Reasons for using a microcontroller in your design
- Features that needs to be considered when selecting a microcontroller
- Key features of an ATmega328P microcontroller 
- Revising C programing basics
 - Variable and data types
 - Operators 
 - Control statements
 - Functions
- Using GPIO on an ATmega328P to interact with external circuitry

---

class: title-slide
layout: false
count: false
.logo-title[]

# Software for the Wireless Energy Monitor
### Functional Requirements 

---

layout: true
name: template_slide

.logo-slide[]
.footer[[Duleepa J Thrimawithana](https://www.linkedin.com/in/duleepajt), Department of Electrical, Computer and Software Engineering (2020)]

---

name: S2

# How Does an Energy Monitor Works?

.center[<img src="img/System.png" height="190">]

- To implement the core energy monitor functionalities we have to
 - Measure the load current and voltage
 - Process these measurements to calculate the power and energy used by the load
- To implement a suitable user interface we may need to
 - Control a display to show the voltage, current, power and energy measurements to the user(s)
 - Communicate these measurements wirelessly with a smart devices
 - Communicate these measurements through serial with a computer

---

name: S3

# How Can we Build an Energy Monitor?

.left-column-s[
- Can we build an energy monitor using hardware only?
 - Electromechanical & analog energy meters have been used in the past
 - Significant design effort required to produce the complex electronic circuits for processing
 - Difficult and costly to modifying the system
- We cannot build an energy monitor using only software
 - Must interact with the physical world to measure voltage and current 
 - Have to produce electrical signals to drive display and serial
 - Electromagnetic waves needed for wireless communication 
- A solution using a mixture of software and hardware is likely to be the best
 - Simpler to build, cheaper, and can be easily iterated to improve the design
 - Hardware is used for interaction with the physical world
 - Software is used to process, control and communicate
]

.right-column-s[
.center[<img src="img/Meter2.png" width="185px">
.credits[
An electro-mechanical meter [[1]](https://en.wikipedia.org/wiki/Electricity_meter)
]
]
.center[<img src="img/Meter1.png" width="185px">
.credits[
The construction [[2]](https://circuitglobe.com/energy-meter.html)
]
]
]

---
name: S4

# The Recommended Design

.center[<img src="img/System2.png" height="170">]

- Hardware is used to sense the AC voltage & current and then condition them
 - Produce level-shifted & filtered AC voltage signals that correspond to source voltage and current
 - Produce rising and falling edges that correspond to zero crossings of source voltage (and current)
- The embedded system (i.e. hardware modules in a microcontroller together with software running on it) process the information and generate control and communication signals  
 - Require developing drivers to interact with hardware modules (e.g. UART, ADC and timers)  
 - Require developing software algorithms to process information and generate outputs
- Off the shelf modules are used for display, Bluetooth and serial

---
name: S5

# Embedded Systems

- An embedded system employs a combination of hardware and software to perform a set of specific functions
 - In our design we use the hardware modules on a microcontroller together with software running on it to process the signals representing voltage and current and generate outputs
- Embedded systems have the following general characteristics
 - Have limited resources  
 - Usually reactive and time-constrained
 - Often part of a larger system
- Resource and timing constraints are the major challenges to developing embedded software
 - Code size should be minimized and algorithms should be optimized
 - Hardware peripherals need to be carefully configured to avoid unpredictable behavior 
 - Interrupts need to be short and carefully consider their priorities as well as nested operation 
- Though a real-time operating system (RTOS) may be used, often designs require custom solutions

---
name: S6

# Functional Requirements  

- Configure the Digital I/O, ADC, UART and Timer peripherals of the microcontroller with appropriate settings for the project
- Take ADC samples of signals representing source current and voltage
 - Samples need to be taken every 1ms or slower using a timer to meet our design specifications
 - First sample taken need to be synchronized with the zero crossing of the voltage signal
 - Aim to collect 50 samples of each signal 
- Use the samples collected to calculate peak current, RMS voltage, power and energy
 - Search for the maximum value in the samples collected to determine peak current
 - Perform numeric calculations using rectangular rule to determine the RMS voltage and power 
 - Sum the power at regular intervals to determine the energy consumption 
- Every 1s send latest data over the UART
 - Data should be in the format "Parameter = XXXX Unit \n" (e.g. Vrms = 14.50 V)
- Using Digital I/O, control the 7-segment display to show new data every 1s 
 - Refresh the digits at a rate of at least 30 Hz with the aid of a timer

---

class: title-slide
layout: false
count: false
.logo-title[]

# Microcontrollers
### An Introduction

---

layout: true
name: template_slide

.logo-slide[]
.footer[[Duleepa J Thrimawithana](https://www.linkedin.com/in/duleepajt), Department of Electrical, Computer and Software Engineering (2020)]

---
name: S7

# What is a Microprocessor?

.center[<img src="img/MPU.png" height="275">]

- Microprocessor is a central processing unit (CPU) on a single IC 
- Microprocessor must have external memories and peripheral I/Os to interact with outside world 
- Peripherals are connected to microprocessor through data and address buses
- The CPU executes software (code) written by a programmer

---
name: S8

# What is a Microcontroller?

.center[<img src="img/MCU.png" height="275">]

- Microcontrollers (MCUs) combine program memory, RAM, hardware I/O peripherals, and a microprocessor in a single IC
- They have fixed hardware which executes software (code)
- By modifying the software executed by the microprocessor we can modify its behavior

---
name: S9

# What are Reconfigurable Integrated Circuits?

.center[<img src="img/FPGA.png" height="275">]

- Field-Programmable Gate Arrays (FPGAs) and Complex Programmable Logic Devices (CPLDs) provide generic logic elements which can be configured to perform arbitrary logic
- The reconfigurable hardware they have is described by software
- By modifying the software which describes the hardware we can modify the behavior of the circuit

---
name: S10

# MCUs vs FPGAs/CPLDs

- Lets explore the differences between MCUs and FPGAs/CPLDs to understand why an MCU is the better option for our project

<table class="tg" style="undefined;table-layout: fixed; width: 650px; margin-left:auto; margin-right:auto;">
  <colgroup>
  <col style="width: 325px">
  <col style="width: 325px">
  </colgroup>
  <thead>
    <tr>
      <th class="tg-dzaw"><span style="color:white">MCUs</span></th>
      <th class="tg-dzaw"><span style="color:white">FPGAs & CPLDs</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="tg-jayl">Fixed circuitry</td>
      <td class="tg-jayl">Flexible circuitry</td>
    </tr>
    <tr>
      <td class="tg-sabo">Executes software</td>
      <td class="tg-sabo">Described by software</td>
    </tr>
    <tr>
      <td class="tg-ig71">Sequential</td>
      <td class="tg-ig71">Parallel</td>
    </tr>
    <tr>
      <td class="tg-sabo">Low processing power</td>
      <td class="tg-sabo">High processing power</td>
    </tr>
    <tr>
      <td class="tg-ig71">General applications</td>
      <td class="tg-ig71">Specific applications</td>
    </tr>
    <tr>
      <td class="tg-sabo"><b>Low power consumption</b></td>
      <td class="tg-sabo">High power consumption</td>
    </tr>
    <tr>
      <td class="tg-ig71"><b>Cheap & widespread</b></td>
      <td class="tg-ig71">Expensive but becoming more widely used</td>
    </tr>
    <tr>
      <td class="tg-sabo"><b>Cheaper development tools</b></td>
      <td class="tg-sabo">Expensive development tools</td>
    </tr>
    <tr>
      <td class="tg-ig71"><b>Easier to get started</b></td>
      <td class="tg-ig71">Harder to get started</td>
    </tr>
  </tbody>
</table>

- It is possible to implement a microcontroller on many reconfigurable hardware devices
- Some of the newer microcontrollers now also have integrated reconfigurable hardware modules

---
name: S11

# What to Consider when Selecting an MCU (PI)?

- There are three core resources which must be considered when selecting an MCU for our project
 - Computational Power
 - Program Memory
 - RAM
- Computational Power
 - This is a measure of how quickly the processor can perform a given task
 - The more computation you need to perform in a given time, the more computational power you need
 - It is a function of clock speed (how quickly an instruction is executed), and the Instruction Set Architecture (how much computation is performed by a given instruction)
 - Different architectures target different levels of computational performance
 - ATmega 328P vs ARM Cortex-A7
 - Measured in Millions-of-Instructions-Per-Second (MIPS), but this is only a guide
 - ATmega 328P – 20 MIPS vs Intel Core I7 – 200,000 MIPS


---
name: S12

# What to Consider when Selecting an MCU (PII)?

- Program Memory (Flash)
 - This is where your code to execute is stored
 - More tasks your program performs, the more code you will require, and the more flash you will need
 - For microcontrollers it is usually measured in kilobytes (KB), or megabytes (MB) (e.g. an ATmega328P has 32 KB of program memory)
- Random Access Memory (RAM)
 - This is where data being processed by the microprocessor is stored, as well as the current microprocessor state
 - The more data you need to store or operate on at a given time, the more RAM you will require
 - For microcontrollers it is usually measured in kilobytes (KB), or megabytes (MB) (e.g. an ATmega328P has 2048 B of RAM)
- Different designs require a different mix of computational power, program memory, and RAM
 - Our design task is simple, and our resource requirements are limited

---
name: S13

# What MCU I/O Peripherals are Important?

- Microcontrollers come with a wide range of I/O peripheral to perform different tasks
- The most common ones, which we will cover in more detail during the course, are
 - General Purpose Input Output (GPIO): Allows generating/reading high or low (digital) signals
 - UART (Universal Asynchronous Receiver Transmitter): Sends and receives binary data using a simple serial protocol
 - Analogue to Digital Converters (ADC): Converts an analogue voltage into a digital value
 - Timers: allow real-time measurements and executing realtime tasks   
- The above listed common I/O peripherals are generally sufficient for simple projects like ours
- There are many more I/O peripherals that we won’t cover but can be important for more complicated projects and these include
 - Communication peripheral such as I2C, SPI, CAN, USB, and Ethernet
 - Digital to Analog Converter (DAC)
 - UI peripheral such as LCD drivers, capacitive touch sensors and audio encoders
 - AES encryption, brown out protection, watchdog timers and low voltage detection

---
name: S14

# Other Important Requirements

- There are a number of other functional and non-functional requirements to consider when selecting a MCU 
 - Power consumption
 - Operating voltage range
 - Operating temperature range
 - Packages available (the size and shape of the actual chip)
 - Compiler support
 - Development tools required
 - Programming tools required
 - Available software libraries
 - Certifications (automotive, aerospace, and military are common ones)
- Typically most important requirements are cost, availability, lead-time and minimum-order-quantity (MoQ)
 - Cost of the devices themselves as well as licenses for tools and software need to be considered

---
name: S15

# Why are We Using an ATmega328P?

- To select an appropriate microcontroller for our project we need to estimate the functional requirements for the parameters we looked at
 - Determining for example the required I/O peripherals and operating voltage are somewhat straightforward as they come from the functional requirements (or the flow diagram)
 - Memory and computational power requirements for example are harder to estimate and often our experience with similar previous projects is needed to do make a good estimate 
- As discussed previously there are many non-functional aspects to think about
 - Cost, availability and support (e.g. application notes, tutorials, books, development tools, libraries, etc.) are very important
 - In many situations we may prefer a familiar device or a device that is easier to use and has a shorter learning curve since development time is a big part of the project cost
- The ATmega328P has all the peripherals we need and has sufficient memory and computational power but also more importantly it is one of the easiest to use, we are familiar with it (learnt in COMPSYS 201) and there is ample support (e.g. https://community.atmel.com)

---
name: S16

# What Other MCUs Can We Use?

- Popular microcontroller vendors include STMicroelectronics, NXP, Renesas, Texas Instruments, Microchip and Silicon Labs and there are thousands of devices to select from

.center[<img src="img/MCUOptions.png" height="360">]


---
name: S17

# The ATmega328P MCU & Tools

- The ATmega328P offers the following 
 - 8-bit processor implementing the Atmel AVR RISC architecture
 - 16 MIPS throughput at 16MHz clock
 - 32 KB of program memory (flash) which is programmable in-system (the ability of microcontrollers to be programmed while installed in a complete system)
 - 2 KB of RAM
 - 3 timers, 8 channel 10-bit SAR type ADC, a USART, and 23 GPIO
 - External and internal interrupt sources
 - Operates from 2.7V to 5.5V from -40°C to 125°C 
- As with COMPSYS 201 we will use the Atmel Studio IDE for development
- We will use the ATmega328PB Xplained Mini evaluation kit to avoid having to build additional circuitry
 - Code written for the ATmega328P is forward compatible with ATmega328PB
- When getting started the most important resource available is the [ATmega328P](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf) datasheet
 - Lists all of the parameters and explains how the I/O peripherals work and how to use them

---
name: S18

# ATmega328P Block Diagram & Pinout

.center[
<img src="img/328PBlock.png" height="450">
<img src="img/328PPins.png" height="450">
]

---
name: S19

# Your Energy Monitor Implementation

- To implement the energy monitor you need to design a PCB that will contain the analogue hardware, an ATmega328PB Xplained Mini and the provided 7-segment display as well as HM-10 BLE modules 
 - To make a compact design you can replace the Xplained Mini with an ATmega328P IC and the support circuitry required for the ATmega328P

.center[
<img src="img/FinalDesign.png" height="275">
]

---

class: title-slide
layout: false
count: false
.logo-title[]

# C Programming Language
### Review of Fundamentals

---

layout: true
name: template_slide

.logo-slide[]
.footer[[Duleepa J Thrimawithana](https://www.linkedin.com/in/duleepajt), Department of Electrical, Computer and Software Engineering (2020)]

---
name: S20

# Programming the ATmega328P

- We will use C, which is extremely common, to develop our embedded software program 
- Using Atmel Studio IDE, we will then compile the program to generate machine code 
- The *ELF* file generated during compiling will be simulated in Proteus to validate our design
 - Prior to this we can also use the debugger available on Atmel Studio to validate our software modules 
- Once we have validated the functionality of the software, we then download *HEX* file onto the MCU program memory
- You will start noticing the benefits of using software as you can iterate through the design much faster in comparison to the time required to iterate hardware
- Your first lab will focus on setting up your development environment and getting a simple program running on Proteus
 - You could also try to run the same program on an Xplained Mini
- The lab will walk you through all of the steps required, so don’t worry if it doesn’t all make sense just yet
 - There are many steps involved in compiling code, debugging on Atmel Studio, simulating on Proteus and finally programming the MCU

---
name: S21

# Variables

- The most commonly used variable types are

<table class="tg" style="undefined;table-layout: fixed; width: 1075px; margin-left:auto; margin-right:auto;">
  <colgroup>
  <col style="width: 150px">
  <col style="width: 375px">
  <col style="width: 25px">
  <col style="width: 150px">
  <col style="width: 375px">
  </colgroup>
  <thead>
    <tr>
      <th class="tg-dzaw"><span style="color:white">Type</span></th>
      <th class="tg-dzaw"><span style="color:white">Properties</span></th>
      <th class="tg-dzaw"><span style="color:white"></span></th>
      <th class="tg-dzaw"><span style="color:white">Type</span></th>
      <th class="tg-dzaw"><span style="color:white">Properties</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="tg-jayl">char</td>
      <td class="tg-jayl">8 bit variable with -128 to 127 range</td>
      <td class="tg-jayl"></td>
      <td class="tg-jayl">unsigned char</td>
      <td class="tg-jayl">8 bit variable with 0 to 255 range</td>
    </tr>
    <tr>
      <td class="tg-sabo">int8_t</td>
      <td class="tg-sabo">8 bit variable with -128 to 127 range</td>
      <td class="tg-sabo"></td>
      <td class="tg-sabo">uint8_t</td>
      <td class="tg-sabo">8 bit variable with 0 to 255 range</td>
    </tr>
    <tr>
      <td class="tg-jayl">int</td>
      <td class="tg-jayl">16 bit variable with -32768 to 32767 range</td>
      <td class="tg-jayl"></td>
      <td class="tg-jayl">unsigned int</td>
      <td class="tg-jayl">16 bit variable with 0 to 65535 range</td>
    </tr>
    <tr>
      <td class="tg-sabo">int16_t</td>
      <td class="tg-sabo">16 bit variable with -32768 to 32767 range</td>
      <td class="tg-sabo"></td>
      <td class="tg-sabo">uint16_t</td>
      <td class="tg-sabo">16 bit variable with 0 to 65535 range</td>
    </tr>
    <tr>
      <td class="tg-jayl">int32_t</td>
      <td class="tg-jayl">32 bit variable with -2147483648 to -2147483647 range</td>
      <td class="tg-jayl"></td>
      <td class="tg-jayl">uint32_t</td>
      <td class="tg-jayl">16 bit variable with 0 to 4294967295 range</td>
    </tr>
    <tr>
      <td class="tg-sabo">float</td>
      <td class="tg-sabo">32 bit variable with ±1.175e-38 to ±3.402e38 range</td>
      <td class="tg-sabo"></td>
      <td class="tg-sabo">bool</td>
      <td class="tg-sabo">1 bit variable (need stdbool.h)</td>
    </tr>
  </tbody>
</table>

- Variables can be declared to have either a local or a global scope
- Variables can be declared as static, extern and/or volatile 
 - A static variable is initialized to 0 at the start of the program and if in a function value is retained after exiting the function
 - Volatile modifier is used to ensure the compiler doesn't optimize away a variable
- Type casting is used to temporarily change the type/size of a variable

---
name: S22

# Assignment and Arithmetic Operators 

.codes[
```c
static volatile char glob_var1, glob_var2, glob_var3;   
                                            //Declaring global variables (initialized to 0 at start)    

int main(void){
  uint8_t loc_var1 = 5;                    //Declaring and initializing the a variable to 5
  uint8_t loc_var2 = 300;                  //Value of loc_var2 will be 44!!!

  //Multiply and modulo operators 
  uint8_t loc_var3 = loc_var1 * 2;        //Value of loc_var3 will be 10
  uint8_t loc_var4 = loc_var1 % 10;       //Value of loc_var4 will be 5

  //Importance of type casting
  float loc_var5 = loc_var1 / 4;          //Value of loc_var5 will be 1!!!
  float loc_var6 = (float)loc_var1 / 4;   //Now loc_var6 will be 1.25
  uint16_t loc_var7 = (uint16_t)loc_var1 * 100 + 100;
                                          //Upcasting loc_var1 as (loc_var1 * 10) > 255

  //Assigning characters, hex and binary values
  glob_var1 = 'A';                        //Value of glob_var1 will be 65
  glob_var2 = 0x41;                       //Value of glob_var2 will be 65
  glob_var3 = 0b01000001;                 //Value of glob_var3 will be 65
}
```
]

---
name: S23

# Bitwise, Logical and Rational Operators 

.codes[
```c
//Bitwise operators: Ones Complement (~), AND (&), XOR (^), OR (|), Left Shift (<<), Right Shift (>>)
uint8_t var1 = 0b00110011;            //Value of var1 will be 0x33 or 51 in decimal
var1 ^= 0b00001111;                   //XOR each bit of var1 with corresponding bit of 0b00001111
                                      //result is assign back to var1 making it 0b00111100
uint8_t var2 = 0b11001100 << 2;       //Shift to left by making var2 = 0b00110000 (each Left Shift == x2)
uint8_t var3 = 0x53 & 0x0F;           //Masking - can be used to mask off last 4-bits (var3 = 0x03)
uint8_t var4 = 0x33 & (1<<1 | 1<<2);  //Selecting 2nd and 3rd bits of 0x33 making var4 = 0x02

//Logical operators: AND (&&), OR (||)
bool var5 = 4 && 2;                   //var5 will be 1 (True)
bool var6 = 4 & 2;                    //var6 will be 0 (False)
bool var7 = 3 & 2;                    //var7 will be 1 (True)

//Rational operators: Equal (==), Not Equal (!=), Less Than (<), Less Than or Equal (<=), 
//More Than (>), More Than or Equal (>=)
bool var8 = 5 >= 10;                  //var8 will be 0 (False)
```
]

- A variable, lets say *var1*, can be also pre or post increment/decrement, using for example *++var1* or *var1++*, respectively
- Compound assignment operators (e.g. * var1 += var2; *) may also be used

---
name: S24

# Control Statements 

.codes[
```c
#define NUMTOCHECK  7                //#define is a preprocessor directive

int main(void){
  uint8_t cnt1 = 0, is_prime = 1;    //Initializing a cnt1 to 0 and is_prime to 1

  //WHILE & FOR loops
  while(cnt1<4){
    cnt1++;                          //Code inside this while loop will be executed 4 times 
  }

  for(uint8_t cnt2 =0; cnt2 < 4; cnt2++){
    cnt1++;                         //Code executed 4 times (cnt2 is not visible outside this loop)
  }

  //IF-ELSE statements - E.g. Checking if NUMTOCHECK is a prime number
  for(uint8_t cnt2 =2; cnt2 < NUMTOCHECK; cnt2++){
    if( (NUMTOCHECK % cnt2) == 0 ){ //If NUMTOCHECK can be divided by a nummber less than that its not a prime
      is_prime = 0;                 //Clears the flag
      break;                        //Breaks the FOR loop as no need to continue
    }
  }
}

```
]


---
name: S25

# Functions 


---

class: title-slide
layout: false
count: false
.logo-title[]

# ATmega328P GPIO
### Configuring and Using GPIO

---

layout: true
name: template_slide

.logo-slide[]
.footer[[Duleepa J Thrimawithana](https://www.linkedin.com/in/duleepajt), Department of Electrical, Computer and Software Engineering (2020)]

---
name: S20

# Memory Mapped Peripherals


---

class: title-slide
layout: false
count: false
.logo-title[]

# Acknowledgments 
#### These slides are adapted from material prepared by Travis Scott & Muhammad Nadeem



    </textarea>

    <!-- 
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    -->    
   
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript">
    </script>


    <script src="remark.min.js" type="text/javascript">
    </script>

    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="terminal.language.js" type="text/javascript"></script>

    <script type="text/javascript">

      var options = {};

      var renderMath = function() {
        renderMathInElement(document.body);
        // or if you want to use $...$ for math,
        renderMathInElement(document.body, {delimiters: [ // mind the order of delimiters(!?)
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\[", right: "\\]", display: true},
        {left: "\\(", right: "\\)", display: false},
        ]});
      }

      var slideshow = remark.create({
        ratio: '16:9',
        slideNumberFormat: '%current%',
        countIncrementalSlides: false,
        renderMath,
        highlightLanguage: 'c',
        highlightStyle: 'github',
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: true,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false,
        },
        
      });

      MathJax.Hub.Config({
          tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          processEscapes: true
          }
      });

      MathJax.Hub.Queue(function() {
          $(MathJax.Hub.getAllJax()).map(function(index, elem) {
              return(elem.SourceElement());
          }).parent().addClass('has-jax');
      });

      MathJax.Hub.Configured();
      
      //Terminal style highligting code
      var highlighted = document.querySelectorAll("code.terminal span.hljs-ansi");
      Array.prototype.forEach.call(highlighted, function(next) {
        next.insertAdjacentHTML("beforebegin", next.textContent);
        next.parentNode.removeChild(next);
      });



    </script>
  </body>
</html>